<snippet>
    <content><![CDATA[
class SegmentTree{
    /* 1 as a root, create with SegmentTree sgt;
       node = 1, start = 1/0, end = n/n-1 */
    // #pragma message("1-indexed, be careful")
public :
    vector<int> segTree;
    int base = INT_MAX; // out of range.

    SegmentTree(){
        segTree.resize(4 * n);
        buildSegTree(1, 1, n);
    }

    int join(int a, int b){
        return min(a, b); 
    }

    void buildSegTree(int node, int start, int end){
        if(start == end)
            segTree[node] = v[start];
        else{
            int mid = start + ((end - start) / 2);
            buildSegTree(2*node, start, mid);
            buildSegTree(2*node+1, mid+1, end);
            segTree[node] = join(segTree[2*node], segTree[2*node+1]);
        }
    }

    void printSegTree(){
        for(auto x : segTree) cout << x << ' ';
        cout << '\n';
    }

    int query(int node, int start, int end, const int &left, const int &right){
        if(start >= left && end <= right) return segTree[node];
        else if(end < left || start > right) return base;
        else{
            int mid = start + ((end - start) / 2);
            return join(query(2*node, start, mid, left, right), 
                        query(2*node+1, mid+1, end, left, right));
        }
    }

    void valueUpdate(int node, int start, int end,
                         const int &index, const int &value){
        if(start == index && end == index)
            segTree[node] = join(segTree[node], value); // change value
        else{
            int mid = start + ((end - start) / 2);
            if(index <= mid) valueUpdate(2*node, start, mid, index, value);
            else valueUpdate(2*node+1, mid+1, end, index, value);
            segTree[node] = join(segTree[2*node], segTree[2*node+1]);
        }
    }

    void rangeUpdate(int node, int start, int end,
                         const int &left, const int &right, const int &value){
        if(start == end)
            if(start >= left && start <= right)
                segTree[node] = join(segTree[node], value);
        else{
            int mid = start + ((end - start) / 2);
            if(left <= mid) // left part
                rangeUpdate(2*node, start, mid, left, right, value);
            if(right >= mid) // right part
                rangeUpdate(2*node+1, mid+1, end, left, right, value);
            segTree[node] = join(segTree[2*node], segTree[2*node+1]);
        }
    }
};]]></content>
    <!-- Optional: Set a tabTrigger to define how to trigger the snippet -->
    <tabTrigger>SEGMENTTREE</tabTrigger>
    <!-- Optional: Set a scope to limit where the snippet will trigger -->
    <scope>source.c++</scope>
    <!-- Check doc for details. -->
</snippet>
